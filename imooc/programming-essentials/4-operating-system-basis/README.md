## 作业管理之进程调度

### 进程调度概述

进程调度是指计算机通过决策决定哪个就绪进程可以获得`CPU`使用权。

- 保留旧进程的运行信息，请出旧进程。
- 选择新进程，准备运行环境并分配`CPU`。

就绪队列的排队机制：将就绪进程按照一定的方式排成队列，以便调度程序可以最快找到就绪进程。

选择运行进程的委派机制：调度程序以一定的策略选择就绪进程，将`CPU`资源分配给它。

新老进程的上下文切换机制：保存当前进程的上下文信息，装入被委派执行进程的运行上下文。

![上下文切换](assets/context-switch.png)

#### 非抢占式的调度

- 处理器一旦分配给某个进程，就让该进程一直使用下去。
- 调度程序不以任何原因抢占正在被使用的处理器。
- 直到进程完成工作或因为`IO`阻塞才会让出处理器。

#### 抢占式的调度

- 允许调度程序以一定的策略暂停当前运行的进程。
- 保存好旧进程的上下文信息，分配处理器给新进程。

\ | 抢占式调度 | 非抢占式调度
:-: | :-: | :-:
系统开销 | 频繁切换，开销大 | 切换次数少，开销小
公平性 | 相对公平 | 不公平
应用 | 通用系统 | 专用系统

### 进程调度算法

#### 先来先服务调度算法

- 就绪队列按先来先服务方式排队，调度就绪队列队头进程。

#### 短进程优先调度算法

- 调度程序优先选择就绪队列中估计运行时间最短的进程。
- 不利于长作业进程的执行。

#### 高优先权优先调度算法

- 进程附带优先权，调度程序优先选择权重高的进程。
- 使得紧迫的任务可以优先处理。

#### 时间片轮转调度算法

- 按先来先服务的原则排列就绪进程。
- 每次从队列头部取出待执行进程，分配一个时间片执行。
- 是相对公平的调度算法，但不能保证及时响应用户。

## 作业管理之死锁

死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。

### 死锁的产生

#### 竞争资源

- 共享资源数量不满足各个进程需求。
- 各个进程之间发生资源竞争导致死锁。

![死锁](assets/dead-lock-resource.png)

- 等待请求的资源被释放。
- 自身占用资源不释放。

#### 进程调度顺序不当

![死锁](assets/dead-lock-dispatch.png)

如果调度顺序为`A -> B -> C -> D`，产生死锁；调度顺序为`A -> D -> B -> C`，不会产生死锁。

#### 死锁的四个必要条件

**互斥条件**

- 进程对资源的使用是排他性的使用。
- 某资源只能由一个进程使用，其他进程需要使用只能等待。

**请求保持条件**

- 进程至少保持一个资源，又提出新的资源请求。
- 新资源被占用，请求被阻塞。
- 被阻塞的进程不释放自己保持的资源。

**不可剥夺条件**

- 进程获得的资源在未完成使用前不能被剥夺。
- 获得的资源只能由进程自身释放。

**环路等待条件**

- 发生死锁时，必然存在进程-资源环形链。

![环形链](assets/dead-lock-ring-chain.png)

### 死锁的处理

#### 预防死锁的方法

破坏死锁的必要条件，即可预防死锁。

**破坏请求保持条件**

- 系统规定进程运行之前，一次性申请所有需要的资源。
- 进程在运行期间不会提出资源请求，从而破坏请求保持条件。

**破坏不可剥夺条件**

- 当一个进程请求新的资源得不到满足时，必须释放占有的资源。
- 进程运行时占有的资源可以被释放，意味着可以被剥夺。

**破坏环路等待条件**

- 可用资源线性排序，申请必须按照需要递增申请。
- 线性申请不再形成环路，从而破坏了环路等待条件。

![资源线性申请](assets/resource-linear-apply.png)

#### 银行家算法

- 是一个可操作的著名的避免死锁的算法。
- 以银行借贷系统分配策略为基础的算法。

![银行家算法](assets/banker-algorithm.png)

![银行家算法](assets/banker-algorithm-2.png)

## 存储管理之内存分配与回收

### 内存分配的过程

#### 单一连续分配

- 单一连续分配是最简单的内存分配方式。
- 只能在单用户、单进程的操作系统中使用。

![单一连续分配](assets/memory-single-contiguous.png)

#### 固定分区分配

- 固定分区分配是支持多道程序的最简单存储分配方式。
- 内存空间被划分为若干固定大小的区域。
- 每个分区只提供给一个程序使用，互不干扰。

![固定分区分配](assets/memory-fixed-partition.png)

#### 动态分区分配

- 根据进程实际需要，动态分配内存空间。
- 相关数据结构、分配算法。

![动态分区空闲表](assets/memory-dynamic-partition-Idle-table.png)

![动态分区空闲链](assets/memory-dynamic-partition-Idle-chain.png)

**首次适应算法(FF)**

- 分配内存时从开始顺序查找适合内存区。
- 若没有合适的空闲区，则该次分配失败。
- 每次从头部开始，使得头部地址空间不断被划分。

**最佳适应算法(BF)**

- 最佳适应算法要求空闲区链表按照容量大小排序。
- 遍历空闲区链表找到最佳合适空闲区。

![最佳适应算法](assets/bf.png)

**快速适应算法(QF)**

- 快速适应算法要求有多个空闲区链表。
- 每个空闲区链表存储一种容量的空闲区。

![快速适应算法](assets/qf.png)

### 内存回收的过程

![内存回收](assets/memory-recovery-1.png)

- 不需要新建空闲链表节点。
- 只需要把空闲区`1`的容量增大为空闲区即可。

![内存回收](assets/memory-recovery-2.png)

- 将回收区与空闲区合并。
- 新的空闲区使用回收区的地址。

![内存回收](assets/memory-recovery-3.png)

- 将空闲区`1`、空闲区`2`和回收区合并。
- 新的空闲区使用空闲区`1`的地址。

![内存回收](assets/memory-recovery-4.png)

- 为回收区创建新的空闲节点。
- 插入到相应的空闲区链表中去。

## 存储管理之段页式存储管理

### 页式存储管理

### 段式存储管理

### 段页式存储管理